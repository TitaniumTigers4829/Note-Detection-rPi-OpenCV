package frc.robot.extras;

public final class BilinearInterpolator_deprecated_please_dont_delete_important_code {

  private final double[][] lookupTable;
  private final double[][] mirrored;
  
  /**
   * Handles finding values through a lookup table in a linear fashion.
   * @param lookupTable an array containing {x, y} points, the x values must be in ascending order.
   */
  public BilinearInterpolator_deprecated_please_dont_delete_important_code(double[][] lookupTable, double[][] mirrored) {
    this.lookupTable = lookupTable;
    this.mirrored = mirrored;
  }

  /**
   * Returns a linearly-interpolated value from the lookup table corresponding to the given input value.
   */
  public double[] getLookupValue(double inputXValue, double inputYValue) {    
    //DO NOT DELETE THESE CASES. WILL BE USED IN THE FUTURE (ideally).


//     if (inputXValue < lookupTable[0][0]) {
//       if (inputYValue < lookupTable[0][1]) {
//         return new double[]{lookupTable[0][2],lookupTable[0][3]};
//       }
//       else if (inputYValue > lookupTable[lookupTable.length - 1][1]) {
//         return new double[]{lookupTable[0][2],lookupTable[lookupTable.length - 1][3]};
//       }
//       else {
//       for(int i = 0; i < lookupTable.length; i++) {
//         if (inputYValue == lookupTable[i][1]) {
//         return new double[]{lookupTable[0][2],lookupTable[i][3]};
//       } else if (inputYValue > lookupTable[i][1] && inputYValue < lookupTable[i + 1][1]) {
//         double slope = (lookupTable[i + 1][3] - lookupTable[i][3]) / (lookupTable[i + 1][1] - lookupTable[i][1]);
//         double yIntercept = lookupTable[i][3];
//         return new double[]{lookupTable[0][2],slope * (inputYValue - lookupTable[i][1]) + yIntercept};
//       }
//       }
//     } 
//   }
//     if (inputXValue > lookupTable[lookupTable.length - 1][0]) {
//       if (inputYValue < lookupTable[0][1]) {
//         return new double[]{lookupTable[lookupTable.length - 1][2],lookupTable[0][3]};
//       }
//       else if (inputYValue > lookupTable[lookupTable.length - 1][1]) {
//         return new double[]{lookupTable[lookupTable.length - 1][2],lookupTable[lookupTable.length - 1][3]};
//       }
//       else {
//       for(int i = 0; i < lookupTable.length; i++) {
//         if (inputYValue == lookupTable[i][1]) {
//         return new double[]{lookupTable[lookupTable.length - 1][2],lookupTable[i][3]};
//       } else if (inputYValue > lookupTable[i][1] && inputYValue < lookupTable[i + 1][1]) {
//         double slope = (lookupTable[i + 1][3] - lookupTable[i][3]) / (lookupTable[i + 1][1] - lookupTable[i][1]);
//         double yIntercept = lookupTable[i][3];
//         return new double[]{lookupTable[lookupTable.length - 1][2],slope * (inputYValue - lookupTable[i][1]) + yIntercept};
//       }
//     }
//   }
// }



//   if (inputYValue < lookupTable[0][1]) {
//       if (inputXValue < lookupTable[0][0]) {
//         return new double[]{lookupTable[0][2],lookupTable[0][3]};
//       }
//       else if (inputXValue > lookupTable[lookupTable.length - 1][0]) {
//         return new double[]{lookupTable[lookupTable.length - 1][2],lookupTable[0][3]};
//       }
//       else {
//       for(int i = 0; i < lookupTable.length; i++) {
//         if (inputXValue == lookupTable[i][0]) {
//         return new double[]{lookupTable[i][2],lookupTable[0][3]};
//       } else if (inputXValue > lookupTable[i][0] && inputXValue < lookupTable[i + 1][0]) {
//         double slope = (lookupTable[i + 1][2] - lookupTable[i][2]) / (lookupTable[i + 1][0] - lookupTable[i][0]);
//         double yIntercept = lookupTable[i][2];
//         return new double[]{slope * (inputXValue - lookupTable[i][1]) + yIntercept, lookupTable[0][3]};
//       }
//       }
//     } 
//   }

//   if (inputYValue > lookupTable[lookupTable.length - 1][1]) {
//       if (inputXValue < lookupTable[0][0]) {
//         return new double[]{lookupTable[0][2],lookupTable[lookupTable.length -1][3]};
//       }
//       else if (inputXValue > lookupTable[lookupTable.length - 1][0]) {
//         return new double[]{lookupTable[lookupTable.length - 1][2],lookupTable[lookupTable.length - 1][3]};
//       }
//       else {
//       for(int i = 0; i < lookupTable.length; i++) {
//         if (inputXValue == lookupTable[i][0]) {
//         return new double[]{lookupTable[i][2],lookupTable[lookupTable.length - 1][3]};
//       } else if (inputXValue > lookupTable[i][0] && inputXValue < lookupTable[i + 1][0]) {
//         double slope = (lookupTable[i + 1][2] - lookupTable[i][2]) / (lookupTable[i + 1][0] - lookupTable[i][0]);
//         double yIntercept = lookupTable[i][2];
//         return new double[]{slope * (inputXValue - lookupTable[i][1]) + yIntercept, lookupTable[lookupTable.length - 1][3]};
//       }
//       }
//     }     
//   }

  //DO NOT DELETE ABOVE.

  //if the note center is in the middle, then only need to do y linear interpolation (no bilinear :)
  if (inputXValue >= 155 && inputXValue<= 165) {
    for (int i = 0; i < lookupTable.length-7; i += 7) {
      if (inputYValue == lookupTable[i][1]) {
      return new double[]{lookupTable[i][2], lookupTable[i][3]};
      }

      else if (inputYValue > lookupTable[i][1] && inputYValue < lookupTable[i+7][1]){
      // if x matches up with a data pt, interpolate between above's data pts' y's to determine pose
      double ySlope = (lookupTable[i + 7][3] - lookupTable[i][3]) / (lookupTable[i + 7][1] - lookupTable[i][1]);
      double yYIntercept = lookupTable[i][3];
      return new double[]{lookupTable[i][2], ySlope * (inputYValue - lookupTable[i][1]) + yYIntercept};
      }
    }


    //in case nothing works or like the note x is good but its too far away in y direction (test)
    return new double[]{0.0,-1.0};

    
  }

  //if the note center is less than half the x_pixels (160)
  if (inputXValue < 160) {
    // if we haven't reached any cases nor the previous case, we cannot interpolate with diagonally farther vector since there are no more data pts
    for (int i = 0; i < mirrored.length-7; i++) {

      if (inputXValue == mirrored[i][0]) {

        if (inputYValue == mirrored[i][1]) {
        return new double[]{mirrored[i][2], mirrored[i][3]};
        }

      //   else {
      //   // if x matches up with a data pt, interpolate between above's data pts' y's to determine pose
      //   double ySlope = (mirrored[i + 7][3] - mirrored[i][3]) / (mirrored[i + 7][1] - mirrored[i][1]);
      //   double yYIntercept = mirrored[i][3];
      //   return new double[]{mirrored[i][2], ySlope * (inputYValue - mirrored[i][1]) + yYIntercept};
      //   }

      // }

      // if (inputYValue  == mirrored[i][1]) {
        
      //   // should never be reached but just in case
      //   if (inputXValue == mirrored[i][0]) {
      //   return new double[]{mirrored[i][2], mirrored[i][3]};
      //   }

      //   else {
      //   // if y matches up with a data pt, interpolate between adjacent (right for over 160) data pts' x's to determine pose
      //   double xSlope = (mirrored[i + 1][2] - mirrored[i][2]) / (mirrored[i + 1][0] - mirrored[i][0]);
      //   double xYIntercept = mirrored[i][3];
      //   return new double[]{xSlope * (inputYValue - mirrored[i][0]) + xYIntercept, mirrored[i][3]};
      //   }

      }
      
      //bilinear interpolation approximation used diagnoal vectored pt
      if (inputXValue < mirrored[i][0] && inputYValue > mirrored[i][1] && inputXValue > mirrored[i+8][0] 
      && inputYValue < mirrored[i+8][1]) {

        double xSlope = (mirrored[i + 8][2] - mirrored[i][2]) / (mirrored[i + 8][0] - mirrored[i][0]);
        double xYIntercept = mirrored[i][3];

        double ySlope = (mirrored[i + 8][3] - mirrored[i][3]) / (mirrored[i + 8][1] - mirrored[i][1]);
        double yYIntercept = mirrored[i][3];

        return new double[]{xSlope * (inputXValue - mirrored[i][0]) + xYIntercept, 
          ySlope * (inputYValue - mirrored[i][1]) + yYIntercept};
      }
    }

    

    //check for last row just to check for x only interpolation or point checking. (You can't do y_interpolation or diagonal)
    for (int i = mirrored.length-8; i < mirrored.length; i++) {
      
      if (inputYValue  == mirrored[i][1]) {
        
        if (inputXValue == mirrored[i][0]) {
        return new double[]{mirrored[i][2], mirrored[i][3]};
        }

        else {
        // if y matches up with a data pt, interpolate between adjacent (right for over 160) data pts' x's to determine pose
        double xSlope = (mirrored[i + 1][2] - mirrored[i][2]) / (mirrored[i + 1][0] - mirrored[i][0]);
        double xYIntercept = mirrored[i][3];
        return new double[]{xSlope * (inputYValue - mirrored[i][0]) + xYIntercept, mirrored[i][3]};
        }

      }
    }

    //if outside the collected data pt range, 
    //then return unused values for now. I could make a handle to get the max one and then 
    //interpolate or get max for both if its outside and thats what the above 4 cases are supposed to do but the 
    //logic may need to be changed
    return new double[]{-1.0,-1.0, 69.0};

  }











  //if the note center is greater than half the x_pixels (160)
  if (inputXValue > 160) {
    // if we haven't reached any cases nor the previous case, we cannot interpolate with diagonally farther vector since there are no more data pts
    for (int i = 0; i < lookupTable.length-7; i++) {

      if (inputXValue == lookupTable[i][0]) {

        if (inputYValue == lookupTable[i][1]) {
        return new double[]{lookupTable[i][2], lookupTable[i][3]};
        }

      //   else {
      //   // if x matches up with a data pt, interpolate between above's data pts' y's to determine pose
      //   double ySlope = (lookupTable[i + 7][3] - lookupTable[i][3]) / (lookupTable[i + 7][1] - lookupTable[i][1]);
      //   double yYIntercept = lookupTable[i][3];
      //   return new double[]{lookupTable[i][2], ySlope * (inputYValue - lookupTable[i][1]) + yYIntercept};
      //   }

      // }

      // if (inputYValue  == lookupTable[i][1]) {
        
      //   // should never be reached but just in case
      //   if (inputXValue == lookupTable[i][0]) {
      //   return new double[]{lookupTable[i][2], lookupTable[i][3]};
      //   }

      //   else {
      //   // if y matches up with a data pt, interpolate between adjacent (right for over 160) data pts' x's to determine pose
      //   double xSlope = (lookupTable[i + 1][2] - lookupTable[i][2]) / (lookupTable[i + 1][0] - lookupTable[i][0]);
      //   double xYIntercept = lookupTable[i][3];
      //   return new double[]{xSlope * (inputYValue - lookupTable[i][0]) + xYIntercept, lookupTable[i][3]};
      //   }

      }
      
      //bilinear interpolation approximation used diagnoal vectored pt
      if (inputXValue > lookupTable[i][0] && inputYValue > lookupTable[i][1] && inputXValue < lookupTable[i+8][0] 
      && inputYValue < lookupTable[i+8][1]) {

        double xSlope = (lookupTable[i + 8][2] - lookupTable[i][2]) / (lookupTable[i + 8][0] - lookupTable[i][0]);
        double xYIntercept = lookupTable[i][3];

        double ySlope = (lookupTable[i + 8][3] - lookupTable[i][3]) / (lookupTable[i + 8][1] - lookupTable[i][1]);
        double yYIntercept = lookupTable[i][3];

        return new double[]{xSlope * (inputXValue - lookupTable[i][0]) + xYIntercept, 
          ySlope * (inputYValue - lookupTable[i][1]) + yYIntercept};
      }
    }





    //check for last row just to check for x only interpolation or point checking. (You can't do y_interpolation or diagonal)
    for (int i = lookupTable.length-8; i < lookupTable.length; i++) {
      
      if (inputYValue  == lookupTable[i][1]) {
        
        if (inputXValue == lookupTable[i][0]) {
        return new double[]{lookupTable[i][2], lookupTable[i][3]};
        }

        else {
        // if y matches up with a data pt, interpolate between adjacent (right for over 160) data pts' x's to determine pose
        double xSlope = (lookupTable[i + 1][2] - lookupTable[i][2]) / (lookupTable[i + 1][0] - lookupTable[i][0]);
        double xYIntercept = lookupTable[i][3];
        return new double[]{xSlope * (inputYValue - lookupTable[i][0]) + xYIntercept, lookupTable[i][3]};
        }

      }
    }

    //if outside the collected data pt range, 
    //then return unused values for now. I could make a handle to get the max one and then 
    //interpolate or get max for both if its outside and thats what the above 4 cases are supposed to do but the 
    //logic may need to be changed
    return new double[]{-1.0,-1.0, 96.0};
  }

        
return new double[]{-1.0,-1.0};

  }
}
